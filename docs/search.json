[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "A blog about tech fundamentals, deep learning, AI, and ethics."
  },
  {
    "objectID": "posts/BE-curriculum/index.html",
    "href": "posts/BE-curriculum/index.html",
    "title": "Why Fundamentals Matter",
    "section": "",
    "text": "I built an HTTP server from scratch a few weeks ago. I was using Node and TypeScript, thinking I knew what I was doing—until I didn’t anymore. As embarassing as it was, I realized that I didn’t fully understand what was going on under the hood. I couldn’t explain why UDP and TCP were different, and I knew nothing about how an operating system really handled a network request. That moment was both harsh and exciting. It exposed a gap in my own knowledge and, I suspect, in the way many of us learn to program.\nThat’s why I co-created a backend fundamentals curriculum. Not long ago, I set out on a challenge to gain hands-on experience with computer programming and networks at a more basic level. I wanted to level up my skills in the core principles of how systems work. I also saw it as an opportunity to learn Rust and Elixir—two languages that force you to think differently about the problems you’re solving, and languages I wanted to try for a while now due to their (awesome) reputation.\nAt its heart, this curriculum isn’t about teaching you what programming is or how to write a “hello world” program. It’s for those of us who have already coded, built applications, and is comfortable with at least one programming language, but who haven’t yet taken the time to understand the mechanics of operating systems, protocols, and network architecture. If you’re completely new to programming, you might be better off with an introductory course. But if you’ve already written some code and used some libraries, you know that most tutorials skip the hard questions (looking at you, boilerplates!).\nI started this journey after my little experiment with the HTTP server. Building something from scratch forced me to ask questions: What happens when a client connects? How do protocols really work? What does it mean for a system to be “distributed”? I dove into topics like the OSI stack, sockets, and ports, and found that the answers were rarely as clear as you’d think. More often than not, you have to piece together a deeper understanding from layers of abstraction. And that’s exactly what this curriculum is designed to do. It aims at stripping away the “glossy” aspect of boilerplates, and get to the fundamentals.\nI co-created the course with a simple goal in mind: take the concepts that are usually hidden in dense textbooks or learned after years of trial and error, and break them down into practical, projects based modules. This curriculum uses books from Andrew Tanenbaum, Donald Knuth, and Linus Torvalds, computer scientist who shaped the way we understand systems today. But how can we tackle the fundamentals from concepts coming from dense books and long computer science curriculum, in a more practical and efficient way? Enter, the DiSSS methodology."
  },
  {
    "objectID": "posts/BE-curriculum/index.html#the-case-for-fundamentals",
    "href": "posts/BE-curriculum/index.html#the-case-for-fundamentals",
    "title": "Why Fundamentals Matter",
    "section": "",
    "text": "I built an HTTP server from scratch a few weeks ago. I was using Node and TypeScript, thinking I knew what I was doing—until I didn’t anymore. As embarassing as it was, I realized that I didn’t fully understand what was going on under the hood. I couldn’t explain why UDP and TCP were different, and I knew nothing about how an operating system really handled a network request. That moment was both harsh and exciting. It exposed a gap in my own knowledge and, I suspect, in the way many of us learn to program.\nThat’s why I co-created a backend fundamentals curriculum. Not long ago, I set out on a challenge to gain hands-on experience with computer programming and networks at a more basic level. I wanted to level up my skills in the core principles of how systems work. I also saw it as an opportunity to learn Rust and Elixir—two languages that force you to think differently about the problems you’re solving, and languages I wanted to try for a while now due to their (awesome) reputation.\nAt its heart, this curriculum isn’t about teaching you what programming is or how to write a “hello world” program. It’s for those of us who have already coded, built applications, and is comfortable with at least one programming language, but who haven’t yet taken the time to understand the mechanics of operating systems, protocols, and network architecture. If you’re completely new to programming, you might be better off with an introductory course. But if you’ve already written some code and used some libraries, you know that most tutorials skip the hard questions (looking at you, boilerplates!).\nI started this journey after my little experiment with the HTTP server. Building something from scratch forced me to ask questions: What happens when a client connects? How do protocols really work? What does it mean for a system to be “distributed”? I dove into topics like the OSI stack, sockets, and ports, and found that the answers were rarely as clear as you’d think. More often than not, you have to piece together a deeper understanding from layers of abstraction. And that’s exactly what this curriculum is designed to do. It aims at stripping away the “glossy” aspect of boilerplates, and get to the fundamentals.\nI co-created the course with a simple goal in mind: take the concepts that are usually hidden in dense textbooks or learned after years of trial and error, and break them down into practical, projects based modules. This curriculum uses books from Andrew Tanenbaum, Donald Knuth, and Linus Torvalds, computer scientist who shaped the way we understand systems today. But how can we tackle the fundamentals from concepts coming from dense books and long computer science curriculum, in a more practical and efficient way? Enter, the DiSSS methodology."
  },
  {
    "objectID": "posts/BE-curriculum/index.html#disss-methodology-deconstructing-selecting-and-sequencing.",
    "href": "posts/BE-curriculum/index.html#disss-methodology-deconstructing-selecting-and-sequencing.",
    "title": "Why Fundamentals Matter",
    "section": "DiSSS Methodology: Deconstructing, Selecting, and Sequencing.",
    "text": "DiSSS Methodology: Deconstructing, Selecting, and Sequencing.\nHow did we envisioned this curriculum? The curriculum is built on the DiSSS methodology from Tim Ferriss: Deconstruction, Selection, Sequencing and Stakes. Why DiSSS? It’s a proven methodology that allow anyone to become an expert in any topic in a short amount of time. I already see the skepticals rolling their eyes. I encourage you to learn more about this methodolgy which allowed people in the world become perfectly fluent in Japanese, Chinese, or German in a few weeks, to gain olympic medeals at an advanced age, or to become cook Chefs starting with no experience. I could not find any DiSSS methodology applied to backend fundamentals, but I don’t think backend fundamentals are more complex than Japanese (or, at least, they seem fairly to be at the same level complexity, if you ask me).\nThe idea behind DiSSS is straightforwad: you take a complex topic, break it into parts, figure out how those parts work on their own, and then put them back together until you see the whole picture. This method allows you to dig into the core building blocks of a topic, and learn how to think about it. And because it is project based, you gain hands-on experience. Naturally, you start to see the patterns in the way systems are built, and that kind of understanding can’t come from following step-by-step tutorials alone.\nThere’s another key idea behind this curriculum: the 80/20 rule. In any field, a small set of skills often accounts for the majority of the results. We focus on that crucial 20%: the fundamental principles of computer science that make you a better engineer. Whether you’re working with Rust, Elixir, Docker, or Kubernetes, the core concepts remain the same. By mastering these fundamentals, you prepare yourself for any language or system you’ll face."
  },
  {
    "objectID": "posts/BE-curriculum/index.html#ais-limits-why-deep-understanding-still-matters",
    "href": "posts/BE-curriculum/index.html#ais-limits-why-deep-understanding-still-matters",
    "title": "Why Fundamentals Matter",
    "section": "AI’s limits: why deep understanding still matters",
    "text": "AI’s limits: why deep understanding still matters\nSome of you might be thinking, “Why bother with all this when AI can do so much of the work for me?” It’s a fair question. The short answer is: the engineers who truly innovate are the ones who understand the fundamentals.\nAI is great for generating code, for automating repetitive tasks, and even for suggesting quick fixes. But if you rely solely on AI, you’re missing something essential. When you run into a problem that isn’t covered by a template or a snippet, it’s your deep understanding of the underlying system that will solve your issue. AI can help you write boilerplate code, but it won’t explain why a thread scheduler behaves in a particular way or how to design a system that remains stable under heavy load.\nIn today’s environment, I found that some developers are satisfied to use tools and frameworks without questioning how they work. I am not blaming, I was also in that mindset. I learned programming through self teaching and then at a coding bootcamp. Coding bootcamp are great to teach you how to make things work, how to build fullstack application in a very pragmatic way. But when it comes to really understand how things work, and if you want to enjoy software engineering, I found it essential to learn the core fundamenetals of computer programming. Plus, this topic is even more relevant today when AI can build a fullstack application in a few hours, with almost no coding required.\nThe point is, if you want to spend your career collaborating with AI rather than being replaced by it, you need to have a solid grasp of the fundamentals. Mid-level developers who coast on surface-level knowledge soon find themselves outpaced. In contrast, those who invest time in mastering core principles become the ones who can tackle complex problems involving architecture and system programming, problems that AI isn’t yet ready to solve on its own (and I can confirm already, try to code in Rust with Cursor. I disabled AI assistance after one day. AI’s output was terrible)."
  },
  {
    "objectID": "posts/BE-curriculum/index.html#curriculum-overview",
    "href": "posts/BE-curriculum/index.html#curriculum-overview",
    "title": "Why Fundamentals Matter",
    "section": "Curriculum overview",
    "text": "Curriculum overview\n\n\n\n\n\n\n\n\nModules\nTopics Covered\nKey Projects\n\n\n\n\n1\nCore Systems & Infrastructure\nMini Network Scanner, OS Scheduler Emulator\n\n\n2\nAdvanced Programming (Rust & Elixir)\nHTTP Microservice in Rust, Real-Time Chat App\n\n\n3\nArchitecture & Full-Stack Integration\nMicroservices Ecosystem, CI/CD Deployment\n\n\n\nThe curriculum is structured into three parts, each building on the last. In the first month, you’ll dive into core systems and infrastructure. You might build a mini network scanner or an operating system scheduler emulator. In the second month, you shift to advanced programming with Rust and Elixir. Here, you build practical projects like an HTTP microservice or a real-time chat app. Finally, in the third month, you step back and look at the bigger picture by integrating your work into a full microservices ecosystem, complete with CI/CD deployment. Each step is designed to push you a little further, until you start thinking like a senior backend engineer.\nWhat matters most is not the language you choose or the framework you use. It’s the way you think about problems. That’s the skill that makes great engineers stand out. When you can break down a problem, understand the underlying mechanics, and then build something new from scratch, you’re doing more than just coding—you’re creating a foundation that will carry you through any technological change.\nI’m not under any illusion that this isn’t a lot of work. The way to see it is more as an initiation and a way to push yourself as a developer, and, let’s not forget: to have fun building things from scratch! You will come out of it transformed, no matter if you manage to finish the projects or not. It prepares you for the challenges ahead, and it pays off. In a world where trends come and go, the deep understanding of how systems work remains constant. It’s a skill set that can’t be outsourced to AI or replaced by a trendy new framework. Personally, I also find a real satisfaction in sweating on hard concepts again, and dig into things in a meaningful way, and not because I am going to be more productive. It’s not about “more and fast”. It’s about less and slow, for the true enjoyment of the engineering craft."
  },
  {
    "objectID": "posts/BE-curriculum/index.html#curious-about-joining-the-journey",
    "href": "posts/BE-curriculum/index.html#curious-about-joining-the-journey",
    "title": "Why Fundamentals Matter",
    "section": "Curious about joining the journey?",
    "text": "Curious about joining the journey?\nSo, if you’re someone who has already written code and feels a bit uneasy when you encounter a concept you don’t fully grasp, this curriculum might be just what you need. It’s not for beginners, but for those who are ready to take the next step. It’s for the aspiring backend engineer who wants to build industry-relevant systems. It’s for the mid-career developer who wants to deepen their knowledge and think like a senior engineer. And it’s for anyone who needs to remember that software engineering is a beautiful craft, and who wants to future-proof their skills by really understanding how software works.\nWe built this course because we believe that the best engineers are those who know how to think clearly about complex systems. They’re not satisfied with just knowing how to use a tool, they want to know how the tool works, and how it can be improved. By working on projects that force you to think critically about the basics, you develop a kind of intuition that can’t be taught in a classroom or generated by AI. And that is the kind of mindset that will not only help you build better software but will also set you apart in an ever-changing field.\nIf you want to be one of those engineers and willing to invest the time to really understand how things work, then have a look to this curriculum. It’s a chance to work on meaningful, mission-driven projects, and to build a skill set that will serve you well no matter what new technology comes along next.\nRight now, I’m testing and refining the curriculum as I go, learning from the process myself. I’m a big open source fan, so the curriculum is public here. Feedback is always welcomed, and people can also join the Discord channel. I see this as part of the learning process—a way to iterate, improve, and build something that really helps people.\nStay curious, Manon"
  },
  {
    "objectID": "posts/how-do-i-know-i-have-enough-data/index.html",
    "href": "posts/how-do-i-know-i-have-enough-data/index.html",
    "title": "How Do You Know You Have Enough Data?",
    "section": "",
    "text": "In the world of deep learning, a common question that arises is, “How do I know if I have enough data?” This is a crucial consideration because the quantity and quality of your data can significantly impact the performance of your model. However, knowing whether your dataset is sufficient isn’t always straightforward and requires a combination of practice and experimentation."
  },
  {
    "objectID": "posts/how-do-i-know-i-have-enough-data/index.html#key-questions-to-ask",
    "href": "posts/how-do-i-know-i-have-enough-data/index.html#key-questions-to-ask",
    "title": "How Do You Know You Have Enough Data?",
    "section": "Key Questions to Ask:",
    "text": "Key Questions to Ask:\n\nIs the model overfitting or underfitting? Overfitting might indicate that the model is too complex for the available data. Underfitting suggests the model may be too simple or not trained enough.\nHow does the model perform on validation or test data? Consistent performance across training and validation sets can indicate sufficient data."
  },
  {
    "objectID": "posts/how-do-i-know-i-have-enough-data/index.html#you-cant-know-if-you-have-enough-until-you-train-the-model",
    "href": "posts/how-do-i-know-i-have-enough-data/index.html#you-cant-know-if-you-have-enough-until-you-train-the-model",
    "title": "How Do You Know You Have Enough Data?",
    "section": "You Can’t Know If You Have Enough Until You Train the Model",
    "text": "You Can’t Know If You Have Enough Until You Train the Model\nThe truth is, you can’t really know if you have enough data until you actually train the model. The process of training helps reveal whether your dataset is capturing the necessary features and patterns to achieve your desired level of performance. You may find that even a small dataset works well with certain problems, especially with the right techniques, like transfer learning or data augmentation."
  },
  {
    "objectID": "posts/how-do-i-know-i-have-enough-data/index.html#advantages-of-training-early",
    "href": "posts/how-do-i-know-i-have-enough-data/index.html#advantages-of-training-early",
    "title": "How Do You Know You Have Enough Data?",
    "section": "Advantages of Training Early:",
    "text": "Advantages of Training Early:\n\nExperimentation: Training early enables experimentation with different models and hyperparameters, helping us to learn what works best for our specific problem.\nUnderstanding Data Needs: Initial training results can inform whether more data is required or if our efforts should focus on optimizing other aspects of the model.\nAvoiding Wasted Effort: We might find that a simple model trained on limited data achieves acceptable results, saving time and resources!\n\nThat being said, the great thing is that there are techniques available to maximise our data, ensuring we can build effective models even with limited datasets (yay!) - Techniques such as data augmentation, transfer learning, and regularization can significantly enhance model performance."
  },
  {
    "objectID": "posts/how-do-i-know-i-have-enough-data/index.html#techniques-to-maximise-our-data-under-constraint-without-enough-data-for-instance",
    "href": "posts/how-do-i-know-i-have-enough-data/index.html#techniques-to-maximise-our-data-under-constraint-without-enough-data-for-instance",
    "title": "How Do You Know You Have Enough Data?",
    "section": "Techniques to maximise our data under constraint (without enough data for instance):",
    "text": "Techniques to maximise our data under constraint (without enough data for instance):\nThe great thing about deep learning is that there are numerous techniques to maximise our data, ensuring we can build effective models even with limited datasets (yay!) - Techniques such as data augmentation, transfer learning, and regularization can significantly enhance model performance.\nStay tuned for a separate article that will delve into these techniques, providing strategies and tips on how to make the most of our available data and improve model performance even with constraints.\n\nKey takeaway: By training our model early and often, we can gain valuable insights into our data’s sufficiency and learn how to make informed decisions about data collection and preprocessing. This approach not only helps build better models but also makes our development process more agile and responsive.\nStay curious! Manon"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome and Why A Blog?",
    "section": "",
    "text": "I hear a lot that blogs are dead.\nMaybe.\nBut I love blogs! So I decided to start one anyways to document my learning journey with deep learning and AI.\nI am learning the fundamentals, and on day two of the fastai course from Jeremy Howard I was able to train my first model to classify bears.\nHOW COOL IS THAT???\nStay curious, Manon"
  },
  {
    "objectID": "posts/fit-function-into-data/index.html",
    "href": "posts/fit-function-into-data/index.html",
    "title": "Fitting a Function to Data in Neural Networks",
    "section": "",
    "text": "In the context of neural networks, “fitting a function to data” refers to the process of training the model to learn the underlying patterns, relationships, or mappings between input data and the desired output. Let’s delve into what this means, why it’s essential, and how it is achieved in practice."
  },
  {
    "objectID": "posts/fit-function-into-data/index.html#what-is-a-function",
    "href": "posts/fit-function-into-data/index.html#what-is-a-function",
    "title": "Fitting a Function to Data in Neural Networks",
    "section": "What is a Function?",
    "text": "What is a Function?\nA function in mathematics is a relation between a set of inputs and a set of possible outputs. In the context of machine learning:\nInput (X): The data we provide to the model (e.g., images, text, numerical features). Output (Y): The prediction or classification that the model generates (e.g., labels, regression values). The neural network acts as a parameterized function 𝑓 ( 𝑋 , 𝜃 ) f(X,θ) where:\n𝑋 X is the input data. 𝜃 θ are the parameters (weights and biases). 𝑓 f is the model that maps inputs to outputs."
  },
  {
    "objectID": "posts/fit-function-into-data/index.html#why-do-we-fit-a-function-into-data",
    "href": "posts/fit-function-into-data/index.html#why-do-we-fit-a-function-into-data",
    "title": "Fitting a Function to Data in Neural Networks",
    "section": "Why Do We Fit a Function into Data?",
    "text": "Why Do We Fit a Function into Data?\n\nLearning Patterns and Relationships Discovering Hidden Structures: Data often contains complex patterns or relationships that are not easily discernible. By fitting a function, a neural network can learn these structures and make sense of the data. Feature Extraction: Neural networks can automatically learn and extract relevant features from raw data, reducing the need for manual feature engineering.\nMaking Predictions Generalization: Once trained, the network should generalize well to unseen data, making accurate predictions based on the learned patterns. Decision Making: Predictions can drive decision-making processes in various applications like self-driving cars, medical diagnosis, etc.\nOptimization and Efficiency Loss Minimization: Fitting involves minimizing a loss function that quantifies the difference between predicted and actual values. The goal is to find parameter values that yield the lowest possible loss. Efficient Representation: Neural networks can efficiently represent complex functions with relatively few parameters compared to traditional models, making them suitable for high-dimensional data."
  },
  {
    "objectID": "posts/fit-function-into-data/index.html#how-does-fitting-work",
    "href": "posts/fit-function-into-data/index.html#how-does-fitting-work",
    "title": "Fitting a Function to Data in Neural Networks",
    "section": "How Does Fitting Work?",
    "text": "How Does Fitting Work?\nThe process of fitting a function to data in a neural network involves several key steps:\n\nInitialization Parameter Initialization: The weights and biases of the network are initialized, often with small random values or specific strategies like Xavier or He initialization.\nForward Pass Data Propagation: The input data is passed through the network layers, and transformations are applied based on the current parameter values to produce an output. Output Prediction: The network generates predictions for the given input data.\nLoss Calculation Define Loss Function: A loss function (e.g., mean squared error, cross-entropy) measures the difference between predicted and actual target values. Calculate Loss: Compute the loss for the given predictions.\nBackward Pass (Backpropagation) Gradient Calculation: Using backpropagation, compute the gradients of the loss with respect to each parameter. This involves applying the chain rule to propagate errors backward through the network. Parameter Update: Update the parameters using optimization algorithms like stochastic gradient descent (SGD) or Adam. The parameters are adjusted in the direction that minimizes the loss.\nIterative Process Epochs and Batches: The process is repeated over multiple iterations (epochs) and for different subsets of data (batches) to refine the parameter values continually. Convergence: The training process aims to converge to a set of parameters that minimize the loss function, achieving a good fit to the training data."
  },
  {
    "objectID": "posts/fit-function-into-data/index.html#why-not-use-traditional-models",
    "href": "posts/fit-function-into-data/index.html#why-not-use-traditional-models",
    "title": "Fitting a Function to Data in Neural Networks",
    "section": "Why Not Use Traditional Models?",
    "text": "Why Not Use Traditional Models?\nTraditional models, such as linear regression, fit simple functions to data, which might be insufficient for complex tasks where:\nNon-linearity: Data relationships are non-linear and require sophisticated functions to capture. High Dimensionality: Inputs are high-dimensional (e.g., images, audio) and need complex architectures. Complex Patterns: Patterns involve intricate interactions that simple models cannot capture effectively. Neural networks excel in these scenarios due to their ability to approximate complex functions."
  },
  {
    "objectID": "posts/fit-function-into-data/index.html#conclusion",
    "href": "posts/fit-function-into-data/index.html#conclusion",
    "title": "Fitting a Function to Data in Neural Networks",
    "section": "Conclusion",
    "text": "Conclusion\nFitting a function to data in neural networks is about learning the optimal parameter values that allow the model to capture underlying patterns and make accurate predictions. This process is central to machine learning, enabling models to generalize from examples and solve real-world problems effectively."
  },
  {
    "objectID": "posts/build-first-model/index.html",
    "href": "posts/build-first-model/index.html",
    "title": "Build your first Deep Learning app",
    "section": "",
    "text": "I made my first ML-powered app in day two of the “Deep Learning Course for Coders” from Jeremy Howard of fastai, my new hero haha.\nTo give you some context, I am fullstack developer with no prior experience in data science and deep learning. I am just interested in learning how deep learning can solve tangible problems, and how teams and people can make ethical decisions based on data.\nToday I am giving back to the community, so we are going to make an image classification model that classifies bears, using fastai, HuggingFace Spaces and Gradio. It’s so inspiring for me to see that in a few lines of code I was able to have something sharable! (You can see it here!)"
  },
  {
    "objectID": "posts/build-first-model/index.html#improving-the-model",
    "href": "posts/build-first-model/index.html#improving-the-model",
    "title": "Build your first Deep Learning app",
    "section": "Improving the model",
    "text": "Improving the model"
  },
  {
    "objectID": "posts/build-first-model/index.html#downloading-the-model",
    "href": "posts/build-first-model/index.html#downloading-the-model",
    "title": "Build your first Deep Learning app",
    "section": "Downloading the model",
    "text": "Downloading the model"
  },
  {
    "objectID": "posts/build-first-model/index.html#gradio-template",
    "href": "posts/build-first-model/index.html#gradio-template",
    "title": "Build your first Deep Learning app",
    "section": "Gradio template",
    "text": "Gradio template"
  },
  {
    "objectID": "posts/build-http-server-from-scratch/index.html",
    "href": "posts/build-http-server-from-scratch/index.html",
    "title": "Building a HTTP Server from Scratch",
    "section": "",
    "text": "Why Build a HTTP server from Scratch?\nFirst, the basics. What Is an HTTP Server?\n\nTCP vs. UDP\n\nKey features of my HTTP Server (Typescript + Nodejs)\nWhat I Learned\n\nLearning 1: Sockets!\nLearning 2: Routing Isn’t That Simple\nLearning 3: Always Try to Break Your Software\n\nWhat’s Next?\nWhy It Matters - Meta Learnings"
  },
  {
    "objectID": "posts/build-http-server-from-scratch/index.html#contents",
    "href": "posts/build-http-server-from-scratch/index.html#contents",
    "title": "Building a HTTP Server from Scratch",
    "section": "",
    "text": "Why Build a HTTP server from Scratch?\nFirst, the basics. What Is an HTTP Server?\n\nTCP vs. UDP\n\nKey features of my HTTP Server (Typescript + Nodejs)\nWhat I Learned\n\nLearning 1: Sockets!\nLearning 2: Routing Isn’t That Simple\nLearning 3: Always Try to Break Your Software\n\nWhat’s Next?\nWhy It Matters - Meta Learnings"
  },
  {
    "objectID": "posts/build-http-server-from-scratch/index.html#why-build-a-http-server-from-scratch",
    "href": "posts/build-http-server-from-scratch/index.html#why-build-a-http-server-from-scratch",
    "title": "Building a HTTP Server from Scratch",
    "section": "Why Build a HTTP server from Scratch?",
    "text": "Why Build a HTTP server from Scratch?\nThese days, you can spin up a fully functional server in minutes with the help of modern tools.\nSo why would anyone bother building an HTTP server from scratch using Nodejs and Typescript?\nFor me, it’s an experiment I am running for the next three months: mastering building blocks fundamentals and re training myself on doing deep work.\nThere is also a simple truth about working in tech: if I am serious about thriving as a full-stack engineer, I surely need to own the basics, and not just know how to work with abstractions and frameworks that do pretty much everything for you.\nBeyond the technical challenge, there’s the simple satisfaction of building something fun and tangible. There’s unparalleled satisfaction in crafting a tool that serves a real purpose, like delivering a web page that serves an HTML page with images and text, using only the basics.\nIt’s a powerful way to deepen your technical skills in a meaningful way while working on something enjoyable."
  },
  {
    "objectID": "posts/build-http-server-from-scratch/index.html#first-the-basics.-what-is-an-http-server",
    "href": "posts/build-http-server-from-scratch/index.html#first-the-basics.-what-is-an-http-server",
    "title": "Building a HTTP Server from Scratch",
    "section": "First, the basics. What Is an HTTP Server?",
    "text": "First, the basics. What Is an HTTP Server?\nAt its core, an HTTP server is a program that listens for incoming HTTP requests from clients (like a browser or API consumer), processes those requests, and sends back responses. It uses the TCP (Transmission Control Protocol) to establish a reliable connection, ensuring that data packets arrive in order and intact.\n\nTCP vs. UDP\nI do mountaineering and one analogy came to me to differentiate TCP and UDP protocols.\n\nTCP: Think of climbers on a glacier roped together. Everyone reaches the summit securely and in order. That’s TCP: ensuring that data (climbers) arrive in order and intact.\nUDP: UDP are like alpinists climbing individually without ropes. It’s usually faster, but there’s no guarantee everyone gets there. Fast, but less reliable."
  },
  {
    "objectID": "posts/build-http-server-from-scratch/index.html#key-features-of-my-http-server-typescript-nodejs",
    "href": "posts/build-http-server-from-scratch/index.html#key-features-of-my-http-server-typescript-nodejs",
    "title": "Building a HTTP Server from Scratch",
    "section": "Key features of my HTTP Server (Typescript + Nodejs)",
    "text": "Key features of my HTTP Server (Typescript + Nodejs)\n\nHandles GET and POST Requests: Responds with a simple “Hello, World!” for basic requests.\nSupports for HTTP/1.1 Protocol: Implements the essentials of this widely-used protocol.\nServes Static Files: Fetches and delivers image files stored in the server’s public/images/ directory.\nRouting: Implements basic routing using if-else statements to handle different endpoints like /api or /.\nError Handling: Ensures proper responses for malformed requests, like returning 400 Bad Request for parsing errors."
  },
  {
    "objectID": "posts/build-http-server-from-scratch/index.html#what-i-learned",
    "href": "posts/build-http-server-from-scratch/index.html#what-i-learned",
    "title": "Building a HTTP Server from Scratch",
    "section": "What I Learned",
    "text": "What I Learned\n\nLearning 1: Sockets!\nSockets are how servers and clients talk to each other. Before this project, I knew about sockets the way most of us know about cars: we press the gas pedal, and the car moves. Magic! Now, I’ve seen how there is nothing magical about it, especially when I wrote the createDataHandler function:\nconst createDataHandler = (\n  socket: net.Socket,\n  handleRequest: (rawRequest: string) =&gt; {\n    statusCode: number;\n    statusMessage: string;\n    headers: Record&lt;string, string&gt;;\n    body: string | Buffer;\n  },\n): ((chunk: Buffer) =&gt; void) =&gt; {\n  let buffer = '';\n  \n  return (chunk: Buffer) =&gt; {\n    buffer += chunk.toString();\n    if (buffer.includes('\\r\\n\\r\\n')) {\n      const response = handleRequest(buffer);\n      if (socket.writable) {\n        socket.write(formatHttpResponse(response));\n        socket.end();\n      } else {\n        logger.error('Socket is not writable, skipping response');\n      }\n    }\n  };\n};\n\nExplanation of createDataHandler Function\ncreateDataHandler is a function that handles incoming TCP data chunks for HTTP requests. It maintains a buffer—a string that accumulates data from incoming chunks.\n\nChunk Conversion: For each chunk, it converts the binary data into a string and appends it to the buffer.\nHeader Detection: It then checks if the buffer contains \\r\\n\\r\\n, which marks the end of the HTTP headers.\nProcessing & Response: If it finds the marker, it processes the request and sends a response.\n\nThis gave me a clearer view of how HTTP works at the lowest level: every incoming request starts as raw data, and the server has to parse it into something usable. Sockets are the invisible ropes that pull these chunks back and forth, and the createDataHandler function is the intermediary which makes something sensible of the data.\nWe can also appreciate how fragile things are: if the buffer isn’t handled properly—by failing to detect the end of the headers, for example—the server breaks. These are things I’ve never appreciated when using frameworks.\n\n\n\nLearning 2: Routing Isn’t That Simple\nManual routing turned out to be more challenging than I expected, especially when it came to handling content types. Frameworks like Express.js make this super easy, but behind the scenes, there’s a lot happening:\n\nContent-Type Handling: My server only supported JSON for request bodies, and I had to set the correct MIME type manually for responses. Adding support for more content types, like multipart/form-data for file uploads or application/x-www-form-urlencoded for form submissions, would require additional parsing logic.\nHeaders Management: In a basic setup, you’re responsible for setting essential headers like Content-Type and Content-Length. Get these values wrong, and the client either won’t understand the response or will hang waiting for more data. This is what happened when my server was not picking up the images/jpeg datatype.\nParsing Body Formats: Each content type requires its own logic. For example, JSON bodies need to be parsed into JavaScript objects, while multipart/form-data requires handling file streams. This complexity grows quickly as you add support for more formats.\n\nExpress.js automates most of this. It detects the Content-Type header, parses the body accordingly, and sets the right MIME type for responses. Doing this manually gave me a deep appreciation for how much work frameworks save.\nWhile my manual routing works for basic cases, it’s clear that scaling it to handle more complex scenarios would require more effort.\n\n\nLearning 3: Always Try to Break Your Software\nSoftware is rarely perfect the first time around. A great way to test my server was to run:\nhey -n 1000 -m GET http://localhost:8080/\n\n\nStress Test Outcome\nBOOM. The server crashed after 800 requests.\nWhy?\nThis command sends 1,000 simultaneous GET requests, simulating real-world stress. It exposed a critical issue: I wasn’t handling socket timeouts properly. My server would hang because it didn’t close idle sockets.\nThe Fix:\nTo fix this, I chose to close the socket after each request, which works great for the scope of this project. But if I wanted to support persistent connections, I’d need to avoid calling socket.end() and implement additional logic. For now, closing the connection after each request is the simplest and safest approach. It’s clean, predictable, and prevents resource leaks."
  },
  {
    "objectID": "posts/build-http-server-from-scratch/index.html#whats-next",
    "href": "posts/build-http-server-from-scratch/index.html#whats-next",
    "title": "Building a HTTP Server from Scratch",
    "section": "What’s Next?",
    "text": "What’s Next?\nThere’s a lot more I can add to this server, which is also the reason why I love to start a project from ZERO. I get to own every bite of it and can add on to it as learning-needs/curiosity fit.\n\nHTTPS: Right now, it’s plain HTTP. Adding SSL/TLS would make it secure.\nWebSockets: For real-time communication, like chat apps.\nAuthentication: Handle user logins and sessions.\nBetter Routing: Add support for more content types and dynamically set MIME types based on file extensions or request content.\nCaching: Improve performance by storing frequently requested data."
  },
  {
    "objectID": "posts/build-http-server-from-scratch/index.html#why-it-matters---meta-learnings",
    "href": "posts/build-http-server-from-scratch/index.html#why-it-matters---meta-learnings",
    "title": "Building a HTTP Server from Scratch",
    "section": "Why It Matters - Meta Learnings",
    "text": "Why It Matters - Meta Learnings\nI am a huge fan of Tim Ferriss, especially when it comes to his lessons on meta learning, or the ability to learn pretty much everything and become a top performer in any field in a short period of time.\nWriting an HTTP server from scratch was a way to dig deeper into one of the fundamental building blocks of full-stack engineering—to deeply understand the web and servers. It was also interesting to see how constraints (not using a framework like Express) force you to think critically and solve problems creatively, which of course deepens my understanding. Last but not least, there’s simply a unique joy in building something functional from scratch! 😃\nYou can check the project on GitHub!\nHappy building!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "‘True intelligence requires empathy, both in humans and machines.’ - Cynthia Rudin",
    "section": "",
    "text": "Why Fundamentals Matter\n\n\n\n\n\n\nfundamentals\n\n\nlearning\n\n\n\n\n\n\n\n\n\nFeb 13, 2025\n\n\nManon Jacquin\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding a HTTP Server from Scratch\n\n\n\n\n\n\nHTTP\n\n\nfundamentals\n\n\ntypescript\n\n\nnodejs\n\n\n\n\n\n\n\n\n\nJan 18, 2025\n\n\nManon Jacquin\n\n\n\n\n\n\n\n\n\n\n\n\nHow Do You Know You Have Enough Data?\n\n\n\n\n\n\ntip\n\n\ndeep learning\n\n\ndata processing\n\n\n\n\n\n\n\n\n\nAug 10, 2024\n\n\nManon Jacquin\n\n\n\n\n\n\n\n\n\n\n\n\nWhat is a neural net?\n\n\n\n\n\n\nbeginner\n\n\ndeep learning\n\n\n\n\n\n\n\n\n\nAug 7, 2024\n\n\nManon Jacquin\n\n\n\n\n\n\n\n\n\n\n\n\nBuild your first Deep Learning app\n\n\n\n\n\n\ntutorial\n\n\nbeginner\n\n\ndeep learning\n\n\n\n\n\n\n\n\n\nJul 10, 2024\n\n\nManon Jacquin\n\n\n\n\n\n\n\n\n\n\n\n\nFitting a Function to Data in Neural Networks\n\n\n\n\n\n\nbeginner\n\n\nfundamentals\n\n\n\n\n\n\n\n\n\nJul 7, 2024\n\n\nManon Jacquin\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome and Why A Blog?\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJul 7, 2024\n\n\nManon Jacquin\n\n\n\n\n\n\nNo matching items"
  }
]